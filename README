Ciulinca Andra Stefania
334CA

APD Homework

The homework statement was finding an inverted index for a group of files. The index will contain a list of every word in the input files and a list of indexes for each word containing the index of the files in which the word appears.
The thread syncronization was done using pthread library, specifically:
Mutexes: to ensure thread-safe access to shared structures (partialList in MapperHelper and aggregatedList in ReducerHelper).
Prevent simultaneous writes by multiple threads.
Barriers: Mapper Barrier: Ensures all mapper threads finish processing before reducers start. Reducer Barrier: Synchronizes reducers to ensure partial list processing is complete before writing final outputs.

Implementing this homework I needed the following structures:

FileQueue: Handles the dynamic distribution of files to mapper threads in a thread-safe manner. A thread-safe queue with mutex protection for pushing and popping file paths. Ensures no two threads access the same file simultaneously.

MapperHelper: Stores intermediate results generated by mapper threads.
Contains a vector of pairs (partialList), where each pair is a word and the file index it came from. Includes a mutex to ensure thread-safe writes by mappers.

ReducerHelper: Stores the aggregated results processed by reducer threads. Uses a nested map structure where:
The outer map has the first letter of words as keys.
The inner map maps each word to a vector of file indices where it appears.
A mutex ensures thread-safe writes by reducers.
ThreadInfo: Encapsulates thread-specific information. Contains the number of mappers and reducers, along with the unique ID of the thread. 

For this we use the Map-Reduce model and to implement this I started by opening the main file containing the number of files that needs to be procossed then, on the next lines, the paths to the files.
Then the structures and barriers need are initialized. To create the threads I used only one for so the mappers and the reducers start at the same time. They are created using the information needed for each thread and the coresponding function(mapper or reducer). The mapper threads need to have in their threadData the queue containing the files, so the files are distributed to the threads dinamycally, then the mapper helper, the fileIndices vector contains the index of every file, a barrier, threadInfo with the number of mappers and reducers and the index of the current thread. The reducers need the mapper helper with the final vector, the threadInfo, a reducerHelper.

In the mapper function every mapper gets a file from the protected queue and procces the words in the file using the manageFileContent function that receives the file, the file index and the mapperHelper structure as parameters. The thread has a map with a word from the file as a key an the index of the file as a value. This map is then added to the partial list, protected by mutex so the threads dont't write in the list at the same time. A barrier is placed so that every mapper finishes adding to the partial list before moving to the reducers.

After every mapper reaches the barrier the reducers start handling the partial list using the processPartialList function. Every reducer handles a part of the partial list and the interval is calculated using the formulas from the pthread laboratory:
int start = ID * (double)N / P;
int end = min((ID + 1) * (double)N / P, N);  
where N is the size of the partial list and P is the number of reducers.
A map with a char as a key and another map as a value is created for the thread the words from the partial list are added to the map according to the first letter of the word. This map is then added to the aggregated 'list' that is also a map that looks like this a(key) : ('are'(key):[1, 2, 3] (value), 'as'(key): [2, 3] (value)) (value for the big map: the aggregatedList), b : ('be': [1]) making sure the there are no duplicated ids and that the file ids are sorted. The map is also protected by a mutex because every reducer is going to access it.
After every reducer reches the reducers barrier every thread needs to handle some letters from the map to create the final files. getLetterInterval function calculates the interval of letters that a reducer thread will process based on:
numReducers: The total number of reducer threads.
threadId: The ID of the current thread.
The alphabet ('a' to 'z') contains 26 letters. The goal is to divide these 26 letters evenly among all the reducers, while taking into account any remaining letters (since 26 may not be divisible evenly by the number of reducers).
lettersPerThread: The base number of letters each reducer should process.
extraLetters: The number of reducers that will handle an extra letter due to the remainder when dividing 26 by numReducers.
The function returns an interval [startLetterIdx, endLetterIdx] representing the range of letters that this reducer thread will process. This interval is used in the processLettersPerThread function.
The reducers start creating the files 'letter'.txt and if in the aggregated list there are words beggining with that letter they are 
added, after sorting them based on the number of file indexes in the vector associated to them. If the number of indexes is the same than they are sorted alphabetically.
After this we have the output files for every letter in the alphabet containing the words starting with that specific letter a list of file indexes.